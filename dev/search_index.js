var documenterSearchIndex = {"docs":
[{"location":"#BranchChain","page":"Home","title":"BranchChain","text":"Documentation for BranchChain.\n\n","category":"section"},{"location":"#BranchChain.BranchChainV1","page":"Home","title":"BranchChain.BranchChainV1","text":"BranchChainV1(; dim=384, depth=6, f_depth=6, config=nothing)\n\nInvariant-point-attention protein design network used inside the branching flow.\n\nThe model takes masked backbone+sequence states together with a scalar time input and predicts updated backbone frames, amino-acid logits, and insertion/deletion logits. The designable region may change size over the flow through the branching process.\n\ndim: embedding width for all single-residue representations.\ndepth: number of main IPA blocks (backbone+sequence transformer layers).\nf_depth: number of late layers that are allowed to update the rigid frames via Framemover.\nconfig: optional configuration object; stored on model.layers.config and passed through but not interpreted here.\n\nThe call overload\n\n(m::BranchChainV1)(t, BSXt, chainids, resinds, breaks; sc_frames=nothing)\n\nis what is actually used during training/sampling. It expects a batched time tensor t, a BranchingState BSXt containing current locations, rotations and amino-acid identities, residue and chain indices, and a Boolean break mask indicating chain discontinuities. If sc_frames (self-conditioning frames) are provided, they are used as an additional template for IPA layers.\n\n\n\n\n\n","category":"type"},{"location":"#BranchChain.X0sampler-Tuple{Any}","page":"Home","title":"BranchChain.X0sampler","text":"X0sampler(root)\n\nSample a random initial branching state Xâ‚€ from the prior. The returned tuple contains random Cartesian coordinates, random SO(3) rotations, and a single dummy amino-acid state (index 21).\n\n\n\n\n\n","category":"method"},{"location":"#BranchChain.X1_modifier-Tuple{Any}","page":"Home","title":"BranchChain.X1_modifier","text":"X1_modifier(X1)\n\nPost-process a target state so that residues marked for deletion use a dummy AA.\n\nThis sets the amino-acid state at indices X1.del to 21 (the dummy residue) in X1.state[3]. It is passed into branching_bridge so that deleted residues have consistent terminal states at t=1.\n\n\n\n\n\n","category":"method"},{"location":"#BranchChain.export_pdb-NTuple{4, Any}","page":"Home","title":"BranchChain.export_pdb","text":"export_pdb(path, samp, chainids, resnums)\n\nWrite a sampled state samp to a PDB file.\n\nConvenience wrapper around ProteinChains.writepdb that routes through gen2prot.\n\n\n\n\n\n","category":"method"},{"location":"#BranchChain.gen2prot-Tuple{Any, Any, Any}","page":"Home","title":"BranchChain.gen2prot","text":"gen2prot(samp, chainids, resnums; name=\"Gen\")\n\nConvert a sampled state into a ProteinStructure.\n\nsamp: a tuple (locs, rots, aas) as returned by the sampler.\nchainids: integer chain IDs for each residue in the flattened representation.\nresnums: residue numbers for each residue.\nname: protein name to use in the resulting structure.\n\n\n\n\n\n","category":"method"},{"location":"#BranchChain.getmask_boundaries-Tuple{Any}","page":"Home","title":"BranchChain.getmask_boundaries","text":"getmask_boundaries(mask)\n\nFind the boundaries of contiguous true runs in a Boolean mask.\n\nReturns two integer vectors (starts, ends) giving the first and last indices for each run of true values in mask. Used to scale a template mask from one chain length to another.\n\n\n\n\n\n","category":"method"},{"location":"#BranchChain.group_mask-Tuple{Any}","page":"Home","title":"BranchChain.group_mask","text":"group_mask(numgroups)\n\nRandomly choose a non-empty subset of group indices to keep.\n\nUsed internally when grouping chains by similar lengths: draws a random number of groups in 1:(numgroups-1) (or 1 if there is only one group) and returns their indices without replacement.\n\n\n\n\n\n","category":"method"},{"location":"#BranchChain.load_model-Tuple{Any}","page":"Home","title":"BranchChain.load_model","text":"load_model(checkpoint)\n\nLoad a pretrained model state from the Hugging Face hub.\n\ncheckpoint: filename or revision string within \"MurrellLab/BFChainStorm\". Returns the \"model_state\" object from the downloaded JLD2 file. Available checkpoints are:\n\"condsegment_v1.jld\"\n\"condchain_v1.jld\"\n\n\n\n\n\n","category":"method"},{"location":"#BranchChain.losses-Tuple{Any, Any, Any}","page":"Home","title":"BranchChain.losses","text":"losses(P, X1hat, ts)\n\nCompute the per-component training losses for a single branching-flow step.\n\nArguments\n\nP: process collection, typically the global P defined internally.\nX1hat: model predictions, as a tuple (frames, aa_logits, split_logits, del_logits) from BranchChainV1.\nts: training batch struct returned by training_prep, containing targets and masks.\n\nReturns a 5-tuple (l_loc, l_rot, l_aas, splits_loss, del_loss) with weighted losses for locations, rotations, amino-acid identities, split counts, and deletion decisions respectively.\n\n\n\n\n\n","category":"method"},{"location":"#BranchChain.nobreaks-Tuple{Any, Any, Any}","page":"Home","title":"BranchChain.nobreaks","text":"nobreaks(resinds, chainids, cmask)\n\nCheck that the masked region does not contain internal chain breaks.\n\nReturns true if, for every pair of adjacent residues where at least one is masked and both belong to the same chain, their residue indices differ by exactly one. Otherwise returns false. This is used as a simple quality flag for sampled design masks.\n\n\n\n\n\n","category":"method"},{"location":"#BranchChain.rand_chain_mask-Tuple{Any}","page":"Home","title":"BranchChain.rand_chain_mask","text":"rand_chain_mask(chainids)\n\nDraw a random chain-level design mask, optionally sharing which chains are kept across chains of similar length.\n\nRoughly:\n\nwith probability 0.2: keep all chains (trues),\notherwise: group chains by similar length, choose some groups to keep (group_mask), and set the corresponding chains to true,\nfalling back to sampling individual chains when no grouping event happens.\n\n\n\n\n\n","category":"method"},{"location":"#BranchChain.rand_mask-Tuple{Any}","page":"Home","title":"BranchChain.rand_mask","text":"rand_mask(chainids)\n\nDraw a random design mask for a protein.\n\nwith probability 0.2: keep all chains (trues),\nwith probability 0.4: sample a random chain-level mask,\nwith probability 0.4: sample a random segment-level mask,\n\n\n\n\n\n","category":"method"},{"location":"#BranchChain.rand_segment_mask-Tuple{Any}","page":"Home","title":"BranchChain.rand_segment_mask","text":"rand_segment_mask(chainids)\n\nDraw a random residue-level design mask that tends to keep similar segments across chains of similar length.\n\nMost of the time it:\n\ngroups chains by (slightly perturbed) length,\npicks some of these groups to keep (group_mask),\nsamples a random sub-mask on a template chain (rand_sub_mask), and\nrescales the masked segments to the other chains in the same group using getmask_boundaries.\n\nOccasionally it instead chooses individual chains to keep and independently samples sub-masks within those chains. The result is always non-empty.\n\n\n\n\n\n","category":"method"},{"location":"#BranchChain.step_spec-Tuple{BranchChain.BranchChainV2, Any, Any, Any}","page":"Home","title":"BranchChain.step_spec","text":"step_spec(model; recycles=3, vidpath=nothing, printseq=true,\n          device=identity, frameid=[1])\n\nBuild a step function compatible with gen that calls the design model.\n\nmodel: a trained BranchChainV1 (or compatible) instance.\nrecycles: number of additional model refinement passes using self-conditioning (sc_frames) before producing the final prediction.\nvidpath: optional folder where intermediate Xt and X1hat PDBs are written for visualization. If nothing, no PDBs are written.\nprintseq: when true, prints the current amino-acid sequence at each step.\ndevice: function to move inputs onto the desired device (e.g. gpu).\nframeid: single-element vector holding a mutable frame counter used in file naming; typically left at the default.\n\n\n\n\n\n","category":"method"},{"location":"#BranchChain.textlog-Tuple{String, Any}","page":"Home","title":"BranchChain.textlog","text":"textlog(filepath, l; also_print=true)\n\nAppend a comma-separated log line to filepath, optionally echoing to stdout.\n\nfilepath: path to the text log file (created if needed).\nl: collection of values to be converted to strings and joined with commas.\nalso_print: when true, prints the same line to stdout.\n\n\n\n\n\n","category":"method"},{"location":"#BranchChain.training_prep-NTuple{5, Any}","page":"Home","title":"BranchChain.training_prep","text":"training_prep(b, dat, deletion_pad, X0_mean_length)\n\nPrepare a mini-batch for training the branching flow / design model.\n\nFor batch indices b, samples masked terminal states from dat, builds a branching bridge, and returns a named tuple with all inputs and targets needed by BranchChainV1 and losses.\n\n\n\n\n\n","category":"method"}]
}
